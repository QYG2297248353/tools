/*
 * @MS 2022-12-13
 * Copyright (c) 2001-2023 萌森
 * 保留所有权利
 * 本软件为萌森工作室所有及包含机密信息，须遵守其相关许可证条款进行使用。
 * Copyright (c) 2001-2023 Meng Sen
 * All rights reserved
 * This software is owned by Mengsen Studio and contains confidential information, and must be used in accordance with its relevant license terms.
 * Website：https://qyg2297248353.top
 */

package com.ms.tools.core.id.factory.tsid;

import com.ms.tools.core.id.factory.tsid.internal.SettingsUtil;

import java.security.SecureRandom;
import java.time.Clock;
import java.time.Instant;
import java.util.Random;
import java.util.function.IntFunction;
import java.util.function.IntSupplier;

/**
 * A class that actually generates Time Sortable Identifiers (TSID).
 * <p>
 * This class is used by {@link TsidCreator}.
 * <p>
 * You can use this class if you need to use a specific random generator
 * strategy. However, most people just need {@link TsidCreator}.
 * <p>
 * TSID is a 64-bit value that has 2 components:
 * <ul>
 * <li><b>Time component (42 bits)</b>: a number of milliseconds since
 * 1970-01-01 (Unix epoch).
 * <li><b>Random component (22 bits)</b>: a sequence of random bits generated by
 * a secure random generator.
 * </ul>
 * <p>
 * The Random component has 2 sub-parts:
 * <ul>
 * <li><b>Node (0 to 20 bits)</b>: a number used to identify the machine or
 * node.
 * <li><b>Counter (2 to 22 bits)</b>: a randomly generated number that is
 * incremented whenever the time component is repeated.
 * </ul>
 * <p>
 * The random component layout depend on the node bits. If the node bits are 10,
 * the counter bits are limited to 12. In this example, the maximum node value
 * is 2^10-1 = 1023 and the maximum counter value is 2^12-1 = 4093. So the
 * maximum TSIDs that can be generated per millisecond per node is 4096.
 * <p>
 * The time component can be incremented by 1 when the counter overflows. This
 * is done to maintain monotonicity and generation speed. Thus, the time
 * embedded in the TSID can be 1ms or more ahead of the system time when the
 * application is requesting more TSIDs than expected in a millisecond.
 * <p>
 * If a system property `tsidcreator.node` or environment variable
 * `TSIDCREATOR_NODE` is defined, it's value is utilized as node identifier. One
 * of them <b>should</b> be defined to embed a machine ID in the generated TSID
 * in order to avoid TSID collisions.
 * <p>
 * If no property or variable is defined, a random node ID is generated at
 * initialization.
 * <p>
 * The default random generator uses {@link SecureRandom}.
 */
public final class TsidFactory {

    static final int NODE_BITS_256 = 8;
    static final int NODE_BITS_1024 = 10;
    static final int NODE_BITS_4096 = 12;
    // Used to preserve monotonicity when the system clock is
    // adjusted by NTP after a small clock drift or when the
    // system clock jumps back by 1 second due to leap second.
    static final int CLOCK_DRIFT_TOLERANCE = 10_000;
    private final int node;
    private final int nodeBits;
    private final int counterBits;
    private final int nodeMask;
    private final int counterMask;
    private final Clock clock;
    private final long customEpoch;
    private final IRandom random;
    private final int randomBytes;
    private int counter;
    private long lastTime;

    // ******************************
    // Constructors
    // ******************************

    /**
     * It builds a generator with a random node identifier from 0 to 1,023.
     * <p>
     * If a system property `tsidcreator.node` or environment variable
     * `TSIDCREATOR_NODE` is defined, it's value is used as node identifier.
     * <p>
     * The node identifier provided by the property or variable is embedded in the
     * generated TSIDs in order to avoid collisions.
     * <p>
     * Instances built by this constructor can generate up to 4,096 TSIDs per
     * millisecond per node.
     */
    public TsidFactory() {
        this(builder());
    }

    /**
     * It builds a generator with a given node identifier from 0 to 1,023.
     * <p>
     * Instances built by this constructor can generate up to 4,096 TSIDs per
     * millisecond per node.
     * <p>
     * The node identifier provided by parameter is embedded in the generated TSIDs
     * in order to avoid collisions.
     *
     * @param node the node identifier
     */
    public TsidFactory(int node) {
        this(builder().withNode(node));
    }

    /**
     * It builds a generator with the given builder.
     *
     * @param builder a builder instance
     */
    private TsidFactory(Builder builder) {

        // setup node bits, custom epoch and random function
        nodeBits = builder.getNodeBits();
        customEpoch = builder.getCustomEpoch();
        random = builder.getRandom();
        clock = builder.getClock();

        // setup constants that depend on node bits
        counterBits = Tsid.RANDOM_BITS - nodeBits;
        counterMask = Tsid.RANDOM_MASK >>> nodeBits;
        nodeMask = Tsid.RANDOM_MASK >>> counterBits;

        // setup how many bytes to get from the random function
        randomBytes = ((counterBits - 1) / 8) + 1;

        // setup the node identifier
        node = builder.getNode() & nodeMask;

        // finally, initialize internal state
        lastTime = clock.millis();
        counter = getRandomCounter();
    }

    /**
     * Returns a new factory for up to 256 nodes and 16384 ID/ms.
     *
     * @return {@link TsidFactory}
     */
    public static TsidFactory newInstance256() {
        return TsidFactory.builder().withNodeBits(NODE_BITS_256).build();
    }

    /**
     * Returns a new factory for up to 256 nodes and 16384 ID/ms.
     *
     * @param node the node identifier
     * @return {@link TsidFactory}
     */
    public static TsidFactory newInstance256(int node) {
        return TsidFactory.builder().withNodeBits(NODE_BITS_256).withNode(node).build();
    }

    /**
     * Returns a new factory for up to 1024 nodes and 4096 ID/ms.
     * <p>
     * It is equivalent to {@code new TsidFactory()}.
     *
     * @return {@link TsidFactory}
     */
    public static TsidFactory newInstance1024() {
        return TsidFactory.builder().withNodeBits(NODE_BITS_1024).build();
    }

    /**
     * Returns a new factory for up to 1024 nodes and 4096 ID/ms.
     * <p>
     * It is equivalent to {@code new TsidFactory(int)}.
     *
     * @param node the node identifier
     * @return {@link TsidFactory}
     */
    public static TsidFactory newInstance1024(int node) {
        return TsidFactory.builder().withNodeBits(NODE_BITS_1024).withNode(node).build();
    }

    /**
     * Returns a new factory for up to 4096 nodes and 1024 ID/ms.
     *
     * @return {@link TsidFactory}
     */
    public static TsidFactory newInstance4096() {
        return TsidFactory.builder().withNodeBits(NODE_BITS_4096).build();
    }

    /**
     * Returns a new factory for up to 4096 nodes and 1024 ID/ms.
     *
     * @param node the node identifier
     * @return {@link TsidFactory}
     */
    public static TsidFactory newInstance4096(int node) {
        return TsidFactory.builder().withNodeBits(NODE_BITS_4096).withNode(node).build();
    }

    // ******************************
    // Public methods
    // ******************************

    /**
     * Returns a builder object.
     * <p>
     * It is used to build a custom {@link TsidFactory}.
     *
     * @return builder
     */
    public static Builder builder() {
        return new Builder();
    }

    /**
     * Returns a TSID.
     *
     * @return a TSID.
     */
    public synchronized Tsid create() {

        long _time = getTime() << Tsid.RANDOM_BITS;
        long _node = (long) node << counterBits;
        long _counter = (long) counter & counterMask;

        return new Tsid(_time | _node | _counter);
    }

    /**
     * Returns the current time.
     * <p>
     * If the current time is equal to the previous time, the counter is incremented
     * by one. Otherwise the counter is reset to a random value.
     * <p>
     * The maximum number of increment operations depend on the counter bits. For
     * example, if the counter bits is 12, the maximum number of increment
     * operations is 2^12 = 4096.
     *
     * @return the current time
     */
    private synchronized long getTime() {

        long time = clock.millis();

        // Check if the current time is the same as the previous time or has moved
        // backwards after a small system clock adjustment or after a leap second.
        // Drift tolerance = (previous_time - 10s) < current_time <= previous_time
        if ((time > lastTime - CLOCK_DRIFT_TOLERANCE) && (time <= lastTime)) {
            counter++;
            // Carry is 1 if an overflow occurs after ++.
            int carry = counter >>> counterBits;
            counter = counter & counterMask;
            time = lastTime + carry; // increment time
        } else {
            // If the system clock has advanced as expected,
            // simply reset the counter to a new random value.
            counter = getRandomCounter();
        }

        // save current time
        lastTime = time;

        // adjust to the custom epoch
        return time - customEpoch;
    }

    /**
     * Returns a random counter value from 0 to 0x3fffff (2^22-1 = 4,194,303).
     * <p>
     * The counter maximum value depends on the node identifier bits. For example,
     * if the node identifier has 10 bits, the counter has 12 bits.
     *
     * @return a number
     */
    private synchronized int getRandomCounter() {

        if (random instanceof ByteRandom) {

            byte[] bytes = random.nextBytes(randomBytes);

            switch (bytes.length) {
                case 1:
                    return (bytes[0] & 0xff) & counterMask;
                case 2:
                    return (((bytes[0] & 0xff) << 8) | (bytes[1] & 0xff)) & counterMask;
                default:
                    return (((bytes[0] & 0xff) << 16) | ((bytes[1] & 0xff) << 8) | (bytes[2] & 0xff)) & counterMask;
            }

        } else {
            return random.nextInt() & counterMask;
        }
    }

    // ******************************
    // Package-private inner classes
    // ******************************

    static interface IRandom {

        public int nextInt();

        public byte[] nextBytes(int length);
    }

    /**
     * A nested class that builds TSID factories.
     * <p>
     * It is used to setup a custom {@link TsidFactory}.
     */
    public static class Builder {

        private Integer node;
        private Integer nodeBits;
        private Long customEpoch;
        private IRandom random;
        private Clock clock;

        /**
         * Set the node identifier.
         * <p>
         * The range is 0 to 2^nodeBits-1.
         *
         * @param node a number between 0 and 2^nodeBits-1.
         * @return {@link Builder}
         */
        public Builder withNode(Integer node) {
            this.node = node;
            return this;
        }

        /**
         * Set the node identifier bits length within the range 0 to 20.
         *
         * @param nodeBits a number between 0 and 20.
         * @return {@link Builder}
         */
        public Builder withNodeBits(Integer nodeBits) {
            if (nodeBits < 0 || nodeBits > 20) {
                throw new IllegalArgumentException("Node bits out of range: [0, 20]");
            }
            this.nodeBits = nodeBits;
            return this;
        }

        /**
         * Set the custom epoch.
         *
         * @param customEpoch an instant that represents the custom epoch.
         * @return {@link Builder}
         */
        public Builder withCustomEpoch(Instant customEpoch) {
            this.customEpoch = customEpoch.toEpochMilli();
            return this;
        }

        /**
         * Set the random generator.
         * <p>
         * The random generator is used to create a random function that is used to
         * reset the counter when the millisecond changes.
         *
         * @param random a {@link Random} generator
         * @return {@link Builder}
         */
        public Builder withRandom(Random random) {
            if (random != null) {
                if (random instanceof SecureRandom) {
                    this.random = new ByteRandom(random);
                } else {
                    this.random = new IntRandom(random);
                }
            }
            return this;
        }

        /**
         * Set the random function.
         * <p>
         * The random function is used to reset the counter when the millisecond
         * changes.
         *
         * @param randomFunction a random function that returns a integer value
         * @return {@link Builder}
         */
        public Builder withRandomFunction(IntSupplier randomFunction) {
            random = new IntRandom(randomFunction);
            return this;
        }

        /**
         * Set the random function.
         * <p>
         * The random function must return a byte array of a given length.
         * <p>
         * The random function is used to reset the counter when the millisecond
         * changes.
         * <p>
         * Despite its name, the random function MAY return a fixed value, for example,
         * if your app requires the counter to be reset to ZERO whenever the millisecond
         * changes, like Twitter Snowflakes, this function should return an array filled
         * with ZEROS.
         * <p>
         * If the returned value is NULL or EMPTY, the factory ignores it and just
         * increments the counter when the millisecond changes, for example, when your
         * app requires the counter to always be incremented, no matter if the
         * millisecond has changed or not, like Discord Snowflakes.
         *
         * @param randomFunction a random function that returns a byte array
         * @return {@link Builder}
         */
        public Builder withRandomFunction(IntFunction<byte[]> randomFunction) {
            random = new ByteRandom(randomFunction);
            return this;
        }

        /**
         * Set the clock to be used in tests.
         *
         * @param clock a clock
         * @return {@link Builder}
         */
        public Builder withClock(Clock clock) {
            this.clock = clock;
            return this;
        }

        /**
         * Get the node identifier.
         *
         * @return a number
         */
        protected Integer getNode() {

            // 2^22 - 1 = 4,194,303
            final int mask = 0x3fffff;

            if (node == null) {
                if (SettingsUtil.getNode() != null) {
                    // use system property or variable
                    node = SettingsUtil.getNode();
                } else {
                    // use random node identifier
                    node = random.nextInt();
                }
            }

            return node & mask;
        }

        /**
         * Get the node identifier bits length within the range 0 to 20.
         *
         * @return a number
         */
        protected Integer getNodeBits() {
            if (nodeBits == null) {
                nodeBits = TsidFactory.NODE_BITS_1024; // 10 bits
            }
            return nodeBits;
        }

        /**
         * Gets the custom epoch.
         *
         * @return a number
         */
        protected Long getCustomEpoch() {
            if (customEpoch == null) {
                customEpoch = Tsid.TSID_EPOCH; // 2020-01-01
            }
            return customEpoch;
        }

        /**
         * Gets the random generator.
         *
         * @return a random generator
         */
        protected IRandom getRandom() {
            if (random == null) {
                withRandom(new SecureRandom());
            }
            return random;
        }

        /**
         * Gets the clock to be used in tests.
         *
         * @return a clock
         */
        protected Clock getClock() {
            if (clock == null) {
                withClock(Clock.systemUTC());
            }
            return clock;
        }

        /**
         * Returns a build TSID factory.
         *
         * @return {@link TsidFactory}
         */
        public TsidFactory build() {
            return new TsidFactory(this);
        }
    }

    static class IntRandom implements IRandom {

        private final IntSupplier randomFunction;

        public IntRandom() {
            this(newRandomFunction(null));
        }

        public IntRandom(Random random) {
            this(newRandomFunction(random));
        }

        public IntRandom(IntSupplier randomFunction) {
            this.randomFunction = randomFunction != null ? randomFunction : newRandomFunction(null);
        }

        protected static IntSupplier newRandomFunction(Random random) {
            Random entropy = random != null ? random : new SecureRandom();
            return entropy::nextInt;
        }

        @Override
        public int nextInt() {
            return randomFunction.getAsInt();
        }

        @Override
        public byte[] nextBytes(int length) {

            int shift = 0;
            long random = 0;
            byte[] bytes = new byte[length];

            for (int i = 0; i < length; i++) {
                if (shift < Byte.SIZE) {
                    shift = Integer.SIZE;
                    random = randomFunction.getAsInt();
                }
                shift -= Byte.SIZE; // 56, 48, 40...
                bytes[i] = (byte) (random >>> shift);
            }

            return bytes;
        }
    }

    static class ByteRandom implements IRandom {

        private final IntFunction<byte[]> randomFunction;

        public ByteRandom() {
            this(newRandomFunction(null));
        }

        public ByteRandom(Random random) {
            this(newRandomFunction(random));
        }

        public ByteRandom(IntFunction<byte[]> randomFunction) {
            this.randomFunction = randomFunction != null ? randomFunction : newRandomFunction(null);
        }

        protected static IntFunction<byte[]> newRandomFunction(Random random) {
            Random entropy = random != null ? random : new SecureRandom();
            return (final int length) -> {
                byte[] bytes = new byte[length];
                entropy.nextBytes(bytes);
                return bytes;
            };
        }

        @Override
        public int nextInt() {
            int number = 0;
            byte[] bytes = randomFunction.apply(Integer.BYTES);
            for (int i = 0; i < Integer.BYTES; i++) {
                number = (number << 8) | (bytes[i] & 0xff);
            }
            return number;
        }

        @Override
        public byte[] nextBytes(int length) {
            return randomFunction.apply(length);
        }
    }
}
