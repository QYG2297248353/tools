/*
 * @MS 2022-12-13
 * Copyright (c) 2001-2023 萌森
 * 保留所有权利
 * 本软件为萌森工作室所有及包含机密信息，须遵守其相关许可证条款进行使用。
 * Copyright (c) 2001-2023 Meng Sen
 * All rights reserved
 * This software is owned by Mengsen Studio and contains confidential information, and must be used in accordance with its relevant license terms.
 * Website：https://qyg2297248353.top
 */

package com.ms.id.factory.uuid.factory;

import com.ms.id.factory.uuid.enums.UuidVersion;
import com.ms.id.factory.uuid.factory.function.ClockSeqFunction;
import com.ms.id.factory.uuid.factory.function.NodeIdFunction;
import com.ms.id.factory.uuid.factory.function.TimeFunction;
import com.ms.id.factory.uuid.factory.function.impl.*;
import com.ms.id.factory.uuid.util.UuidTime;
import com.ms.id.factory.uuid.util.internal.ByteUtil;
import com.ms.id.factory.uuid.util.internal.SettingsUtil;

import java.time.Instant;
import java.util.UUID;

/**
 * Abstract factory for creating time-based unique identifiers (UUIDv1, UUIDv2
 * and UUIDv6).
 * <p>
 * The time stamp has 100-nanoseconds resolution, starting from 1582-10-15,
 * which is a date known as Gregorian Epoch. The the time stamp rolls over
 * around AD 5235 (1582 + 2^60 / 365.25 / 24 / 60 / 60 / 10000000).
 * <p>
 * The node identifier can be:
 * <ul>
 * <li>A MAC address;
 * <li>A hash of host name, MAC and IP;
 * <li>A random number that always changes;
 * <li>A specific number chosen by someone.
 * </ul>
 * <p>
 * The node identifier used by this factory can be controlled by defining a
 * system property <code>'uuidcreator.node'</code> or an environment variable
 * <code>'UUIDCREATOR_NODE'</code>. The system property has preference over the
 * environment variable.
 * <p>
 * Options accepted by the system property and the environment variable:
 * <ul>
 * <li>The string "mac" for using the MAC address;
 * <li>The string "hash" for using a hash of host name, MAC and IP;
 * <li>The string "random" for using a random number that always changes;
 * <li>The string representation of a specific number between 0 and 2^48-1.
 * </ul>
 * <p>
 * If a property or variable is defined, all UUIDs generated by this factory
 * will be based on it.
 * <p>
 * Otherwise, if no property or variable is defined, a random node identifier is
 * generated once at instantiation. This is the default.
 * <p>
 * Example of system property definition:
 *
 * <pre>{@code
 * # Append to VM arguments
 * -Duuidcreator.node="mac"
 * }</pre>
 * <p>
 * Example of environment variable definition:
 *
 * <pre>{@code
 * # Append to ~/.profile
 * export UUIDCREATOR_NODE="mac"
 * }</pre>
 *
 * @see TimeFunction
 * @see NodeIdFunction
 * @see ClockSeqFunction
 * @see <a href= "https://www.rfc-editor.org/rfc/rfc4122#section-4.2">RFC-4122 -
 * 4.2. Algorithms for Creating a Time-Based UUID</a>
 */
public abstract class AbstTimeBasedFactory extends UuidFactory implements NoArgsFactory {

    private static final String NODE_MAC = "mac";
    private static final String NODE_HASH = "hash";
    private static final String NODE_RANDOM = "random";
    private static final long EPOCH_TIMESTAMP = TimeFunction.toUnixTimestamp(UuidTime.EPOCH_GREG);
    protected TimeFunction timeFunction;
    protected NodeIdFunction nodeidFunction;
    protected ClockSeqFunction clockseqFunction;

    /**
     * A protected constructor that receives a builder object.
     *
     * @param version the version number (1, 2 or 6)
     * @param builder a builder object
     */
    protected AbstTimeBasedFactory(UuidVersion version, Builder<?, ?> builder) {
        super(version);
        timeFunction = builder.getTimeFunction();
        nodeidFunction = builder.getNodeIdFunction();
        clockseqFunction = builder.getClockSeqFunction();
    }

    /**
     * 选择节点标识符函数。
     * 此方法读取系统属性“uuidcreator.node”和环境变量“UUIDCREATOR_NODE”来决定必须使用哪个节点标识符函数。
     * 1. 如果找到字符串“mac”，生成器将使用 MAC 地址。
     * 2. 如果找到字符串“hash”，生成器将使用系统数据哈希。
     * 3. 如果找到字符串“random”，生成器将使用一个总是变化的随机数。
     * 4. 如果它找到特定数字的八进制、十六进制或十进制格式的字符串表示，生成器将使用所表示的数字。
     * 5. 否则，生成器将使用随机数。
     *
     * @return 节点函数
     */
    protected static NodeIdFunction selectNodeIdFunction() {

        String string = SettingsUtil.getProperty(SettingsUtil.PROPERTY_NODE);

        if (NODE_MAC.equalsIgnoreCase(string)) {
            return new MacNodeIdFunction();
        }

        if (NODE_HASH.equalsIgnoreCase(string)) {
            return new HashNodeIdFunction();
        }

        if (NODE_RANDOM.equalsIgnoreCase(string)) {
            return new RandomNodeIdFunction();
        }

        Long number = SettingsUtil.getNodeIdentifier();
        if (number != null) {
            long nodeid = NodeIdFunction.toExpectedRange(number);
            return () -> nodeid;
        }

        return new DefaultNodeIdFunction();
    }

    /**
     * Select the time function.
     * <p>
     * If the operating system is WINDOWS, it returns a function that is more
     * efficient for its typical time granularity (15.6ms). Otherwise, it returns
     * the default time function.
     *
     * @return a time function
     */
    protected static TimeFunction selectTimeFunction() {

        // check if the operating system is WINDOWS
        String os = System.getProperty("os.name");
        if (os != null && os.toLowerCase().startsWith("win")) {
            return new WindowsTimeFunction();
        }

        return new DefaultTimeFunction();
    }

    /**
     * Returns a time-based UUID.
     *
     * @return a time-based UUID
     */
    @Override
    public synchronized UUID create() {

        // Get the time stamp
        long timestamp = TimeFunction.toExpectedRange(timeFunction.getAsLong() - EPOCH_TIMESTAMP);

        // Get the node identifier
        long nodeIdentifier = NodeIdFunction.toExpectedRange(nodeidFunction.getAsLong());

        // Get the clock sequence
        long clockSequence = ClockSeqFunction.toExpectedRange(clockseqFunction.applyAsLong(timestamp));

        // Format the most significant bits
        long msb = formatMostSignificantBits(timestamp);

        // Format the least significant bits
        long lsb = formatLeastSignificantBits(nodeIdentifier, clockSequence);

        return new UUID(msb, lsb);
    }

    /**
     * Returns the most significant bits of the UUID.
     * <p>
     * It implements the algorithm for generating UUIDv1.
     *
     * @param timestamp the number of 100-nanoseconds since 1970-01-01 (Unix epoch)
     * @return the MSB
     */
    protected long formatMostSignificantBits(long timestamp) {
        return ((timestamp & 0x0fff_0000_00000000L) >>> 48) //
                | ((timestamp & 0x0000_ffff_00000000L) >>> 16) //
                | ((timestamp & 0x0000_0000_ffffffffL) << 32) //
                | 0x0000000000001000L; // apply version 1
    }

    /**
     * Returns the least significant bits of the UUID.
     *
     * @param nodeIdentifier a node identifier
     * @param clockSequence  a clock sequence
     * @return the LSB
     */
    protected long formatLeastSignificantBits(long nodeIdentifier, long clockSequence) {
        return ((((clockSequence << 48) | (nodeIdentifier & 0x0000ffffffffffffL)) //
                & 0x3fffffffffffffffL) // clear variant bits
                | 0x8000000000000000L); // apply variant bits
    }

    /**
     * Abstract builder for creating a time-based factory.
     */
    public abstract static class Builder<T, B extends Builder<T, B>> {

        protected TimeFunction timeFunction;
        protected NodeIdFunction nodeidFunction;
        protected ClockSeqFunction clockseqFunction;

        protected TimeFunction getTimeFunction() {
            if (timeFunction == null) {
                timeFunction = selectTimeFunction();
            }
            return timeFunction;
        }

        protected NodeIdFunction getNodeIdFunction() {
            if (nodeidFunction == null) {
                nodeidFunction = selectNodeIdFunction();
            }
            return nodeidFunction;
        }

        protected ClockSeqFunction getClockSeqFunction() {
            if (clockseqFunction == null) {
                clockseqFunction = new DefaultClockSeqFunction();
            }
            return clockseqFunction;
        }

        public B withTimeFunction(TimeFunction timeFunction) {
            this.timeFunction = timeFunction;
            return (B) this;
        }

        public B withNodeIdFunction(NodeIdFunction nodeidFunction) {
            this.nodeidFunction = nodeidFunction;
            return (B) this;
        }

        public B withClockSeqFunction(ClockSeqFunction clockseqFunction) {
            this.clockseqFunction = clockseqFunction;
            return (B) this;
        }

        public B withInstant(Instant instant) {
            long timestamp = TimeFunction.toUnixTimestamp(instant);
            timeFunction = () -> timestamp;
            return (B) this;
        }

        public B withClockSeq(long clockseq) {
            long clockSequence = ClockSeqFunction.toExpectedRange(clockseq);
            clockseqFunction = x -> clockSequence;
            return (B) this;
        }

        public B withClockSeq(byte[] clockseq) {
            long clockSequence = ClockSeqFunction.toExpectedRange(ByteUtil.toNumber(clockseq));
            clockseqFunction = x -> clockSequence;
            return (B) this;
        }

        public B withNodeId(long nodeid) {
            long nodeIdentifier = NodeIdFunction.toExpectedRange(nodeid);
            nodeidFunction = () -> nodeIdentifier;
            return (B) this;
        }

        public B withNodeId(byte[] nodeid) {
            long nodeIdentifier = NodeIdFunction.toExpectedRange(ByteUtil.toNumber(nodeid));
            nodeidFunction = () -> nodeIdentifier;
            return (B) this;
        }

        public B withMacNodeId() {
            nodeidFunction = new MacNodeIdFunction();
            return (B) this;
        }

        public B withHashNodeId() {
            nodeidFunction = new HashNodeIdFunction();
            return (B) this;
        }

        public B withRandomNodeId() {
            nodeidFunction = new RandomNodeIdFunction();
            return (B) this;
        }

        public abstract T build();
    }
}
